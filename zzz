local Settings = {
    -- aimbot
    CursorAim = false,
    CursorAimTargetType = 0,
    CursorAimType = 0,
    CursorAimBindHeld = false,
    CursorAimSensitivity = 1,

    SilentAim = false,
    SilentAimType = 0,

    -- esp
    ESP = false,
    ESPRadius = 500,

    -- melee
    MaxMeleeDamage = false,
    InstantKill = false,
    
    -- misc
    FOVRadius = 150,
    EnterFrenchHouse = false,
}

local TargetPlayer = nil
local NetworkClient = nil

local function GetIdentifier(EventName)
    local success, result = pcall(function()
        if not NetworkClient then
            for _, script in pairs(getscripts()) do
                if script.Name == "NetworkClient" then
                    NetworkClient = script
                    break
                end
            end
        end

        if not NetworkClient then
            return nil, "NetworkClient script not found."
        end

        local req = require(NetworkClient)
        local event = req.getEvent(EventName)
        
        if event then
            return event.identifier
        else
            return nil, "Event not found."
        end
    end)

    if not success then
        print("Unexpected error:", result)
        return nil
    end

    return result
end

local Identifiers = {
    SelfReport = GetIdentifier("SelfReport"),
    FireProjectile = GetIdentifier("FireProjectile"),
    DealShot = GetIdentifier("DealShot"),
    DealMelee = GetIdentifier("DealMelee"),
}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = game.Workspace.CurrentCamera
local Players = game:GetService("Players")
local LP = Players.LocalPlayer

local Network = ReplicatedStorage:WaitForChild("Network")
local RemoteEvent = Network:WaitForChild("RemoteEvent")

local DAMAGE_FORMAT	= "B"
local DAMAGE_PACK = string.pack(DAMAGE_FORMAT, 50)

local espObjects = {}
local LastMeleeTick = tick()

local function DealShot(TargetPlayer)
    local args = {
        {
            [Identifiers.DealShot] = {
                {
                    TargetPlayer,
                    false
                }
            }
        }
    }

    RemoteEvent:FireServer(unpack(args))
end

local function DealMelee(TargetPlayer, MeleeAmount, Twice)
    if TargetPlayer and TargetPlayer.Character and TargetPlayer.Character:FindFirstChild("Humanoid") then
        local args = {
            {
                [Identifiers.DealMelee] = {
                    {
                        TargetPlayer,
                        DAMAGE_PACK
                    }
                }
            }
        }

        LastMeleeTick = tick()

        if Twice then
            RemoteEvent:FireServer(unpack(args))
            RemoteEvent:FireServer(unpack(args))
            Humanoid.Health = 0
            return
        end

        RemoteEvent:FireServer(unpack(args))

        local Humanoid = TargetPlayer.Character.Humanoid
        local TargetHP = Humanoid.Health
        local DamageToApply = math.max(0, 50 - MeleeAmount)

        if DamageToApply > 0 then
            Humanoid.Health = math.max(0, TargetHP - DamageToApply)
        end
    end
end

local mt = getrawmetatable(game)
if setreadonly then
    setreadonly(mt, false)
else
    make_writeable(mt)
end

local old = mt.__namecall
mt.__namecall = newcclosure(function(self, ...)
    local args = {...}
    local method = getnamecallmethod()

    if method == "FireServer" then
        local Break = false

        local success, err = pcall(function()
            if typeof(args) ~= "table" then
                return old(self, unpack(args))
            end

            for _, v in pairs(args) do
                if typeof(v) == "table" then
                    for Key, data in pairs(v) do
                        if typeof(Key) ~= "string" and typeof(Key) ~= "number" then
                            warn("Invalid table key:", Key)
                            continue
                        end
                        if Key == Identifiers.SelfReport then
                            for _, reasonTable in pairs(data) do
                                for i, reason in pairs(reasonTable) do
                                    if i == 2 then
                                        print("gory tried selfreporting :moyai:", reason)
                                    end
                                end
                            end
                            Break = true
                        end

                        if Settings.SilentAim and Key == Identifiers.FireProjectile then
                            DealShot(TargetPlayer)
                        end

                        if Key == Identifiers.DealMelee and Settings.MaxMeleeDamage and not Settings.InstantKill then
                            local CurrentTick = tick()
                            local Diff = CurrentTick - LastMeleeTick

                            if Diff < 0.2 then
                                return
                            end

                            local Player = nil
                            local MeleeAmount = nil
                            for _, table in pairs(data) do
                                for _, TableContent in pairs(table) do
                                    if typeof(TableContent) == "Instance" and TableContent:IsA("Player") then
                                        Player = TableContent
                                    elseif typeof(TableContent) == "string" then
                                        MeleeAmount = string.unpack(DAMAGE_FORMAT, TableContent)
                                    end
                                end
                            end

                            if Player and MeleeAmount then
                                DealMelee(Player, MeleeAmount)
                            end

                            Break = true
                        end

                        if Key == Identifiers.DealMelee and Settings.InstantKill then
                            local CurrentTick = tick()
                            local Diff = CurrentTick - LastMeleeTick

                            if Diff < 0.2 then
                                return
                            end

                            local Player = nil
                            local MeleeAmount = nil
                            for _, table in pairs(data) do
                                for _, TableContent in pairs(table) do
                                    if typeof(TableContent) == "Instance" and TableContent:IsA("Player") then
                                        Player = TableContent
                                    elseif typeof(TableContent) == "string" then
                                        MeleeAmount = string.unpack(DAMAGE_FORMAT, TableContent)
                                    end
                                end
                            end

                            if Player and MeleeAmount then
                                DealMelee(Player, MeleeAmount, true)
                            end

                            Break = true
                        end
                    end
                end
            end
        end)

        if not success then
            warn("Unexpected Error:", err)
        end

        if Break == true then
            return
        end
    end

    return old(self, unpack(args))
end)

if setreadonly then
    setreadonly(mt, true)
else
    make_readonly(mt)
end

local function ReturnKeys()
    local response = game:HttpGet("https://script.google.com/macros/s/AKfycbwpiBSmSyX8S0ojYgu0sNNhs6IfkFdjJ0H4p4eC4nurq4hXM_aGelK0pbJAXkBQd17UVQ/exec")
    local keys = HttpService:JSONDecode(response)

    local Tokens = {}
    for _, keyData in ipairs(keys) do
        if keyData[2] == LP.UserId and keyData[4] == false then
            return {keyData[1]}
        end
        table.insert(Tokens, keyData[1])

        if keyData[4] == true then
            continue
        end
    end

    return Tokens
end

local function LoadUI()
    local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/bruhmoments1234/rblx/refs/heads/main/RayfieldLib'))()
    local Window = Rayfield:CreateWindow({
        Name = "Spain Client for Napoleonic Wars",
        Icon = 10183122096,
        LoadingTitle = "Spain Client",
        LoadingSubtitle = "by Orpios",
        Theme = "Bloom",
    
        DisableRayfieldPrompts = false,
        DisableBuildWarnings = false,
    
        ConfigurationSaving = {
            Enabled = false,
            FolderName = "SpainClient",
            FileName = "Config"
        },
    
        Discord = {
            Enabled = false,
            Invite = "noinvitelink",
            RememberJoins = true
        },
    
        KeySystem = true,
        KeySettings = {
            Title = "Spain Client",
            Subtitle = "Key System",
            Note = "Ask the script owner.",
            FileName = "Key",
            SaveKey = true,
            GrabKeyFromSite = false,
            Key = ReturnKeys()
        }
    })
    
    local HomeTab = Window:CreateTab("Home", "home")
    HomeTab:CreateParagraph({Title = "Disclaimer!", Content = "The Spain Client is not responsible for any actions taken by the user. The script may experience errors or malfunctions, and its use may result in account blacklisting or other penalties. By using this script, you acknowledge and accept the potential risks. We do not assume any liability for bans, blacklisting, or any other consequences that may arise."})
    
    local AimbotTab = Window:CreateTab("Aimbot", "crosshair")
    AimbotTab:CreateSection("Cursor Aim")
    AimbotTab:CreateToggle({
        Name = "Cursor Aim",
        CurrentValue = Settings.CursorAim,
        Flag = "CursorAim",
        Callback = function()
            Settings.CursorAim = not Settings.CursorAim
        end,
    })

    AimbotTab:CreateDropdown({
        Name = "Target Type",
        Options = {"Closest to cursor", "Closest to cursor within FOV circle"},
        CurrentOption = {"Not Selected"},
        MultipleOptions = false,
        Flag = "CursorAimTargetType",
        Callback = function(Options)
            if Options[1] == "Closest to cursor within FOV circle" then
                Settings.CursorAimTargetType = 1
            elseif Options[1] == "Closest to cursor" then
                Settings.CursorAimTargetType = 2
            end
        end,
     })

    AimbotTab:CreateDropdown({
        Name = "Cursor Aim Type",
        Options = {"Slowly aim at target, smoothing applied", "Snap on the player, no smoothing applied (BROKEN)"},
        CurrentOption = {"Not Selected"},
        MultipleOptions = false,
        Flag = "CursorAimType",
        Callback = function(Options)
            if Options[1] == "Slowly aim at target, smoothing applied" then
                Settings.CursorAimType = 1
            elseif Options[1] == "Snap on the player, no smoothing applied (BROKEN)" then
                Settings.CursorAimType = 2
            end
        end,
     })

    AimbotTab:CreateKeybind({
        Name = "Cursor Aim Keybind",
        CurrentKeybind = "E",
        HoldToInteract = true,
        Flag = "CursorAimKeybind",
        Callback = function(Keybind)
            Settings.CursorAimBindHeld = Keybind
        end,
    })

    AimbotTab:CreateSection("Silent Aim")
    AimbotTab:CreateToggle({
        Name = "Silent Aim",
        CurrentValue = Settings.SilentAim,
        Flag = "SilentAim",
        Callback = function()
            Settings.SilentAim = not Settings.SilentAim
        end,
    })

    AimbotTab:CreateDropdown({
        Name = "Silent Aim Type",
        Options = {"Kill when mouse over player when firing", "Kill closest player in FOV circle when firing", "Rage Aim (Old Method, accidentally get extreme distances, closest to mouse)"},
        CurrentOption = {"Not Selected"},
        MultipleOptions = false,
        Flag = "SilentAimType",
        Callback = function(Options)
            if Options[1] == "Kill when mouse over player when firing" then
                Settings.SilentAimType = 1
            elseif Options[1] == "Kill closest player in FOV circle when firing" then
                Settings.SilentAimType = 2
            elseif Options[1] == "Rage Aim (Old Method, accidentally get extreme distances, closest to mouse)" then
                Settings.SilentAimType = 3
            end
        end,
    })

    local ESPTab = Window:CreateTab("ESP", "square")

    ESPTab:CreateToggle({
        Name = "ESP",
        CurrentValue = Settings.ESP,
        Flag = "ESP",
        Callback = function()
            Settings.ESP = not Settings.ESP
        end,
    })

    ESPTab:CreateSlider({
        Name = "ESP Radius",
        Range = {0, 10000},
        Increment = 10,
        Suffix = "Radius",
        CurrentValue = Settings.ESPRadius,
        Flag = "ESPRadius",
        Callback = function(Value)
            Settings.ESPRadius = Value
        end,
    })

    local MeleeTab = Window:CreateTab("Melee", "sword")
    MeleeTab:CreateSection("Melee")

    MeleeTab:CreateToggle({
        Name = "Max Melee Damage",
        CurrentValue = Settings.MaxMeleeDamage,
        Flag = "MaxMeleeDamage",
        Callback = function()
            Settings.MaxMeleeDamage = not Settings.MaxMeleeDamage
        end,
    })

    MeleeTab:CreateToggle({
        Name = "Instant Kill",
        CurrentValue = Settings.InstantKill,
        Flag = "InstantKill",
        Callback = function()
            Settings.InstantKill = not Settings.InstantKill
        end,
    })

    local MiscTab = Window:CreateTab("Misc", "pipette")
    MiscTab:CreateSlider({
        Name = "FOV Radius",
        Range = {0, 1500},
        Increment = 5,
        Suffix = "Radius",
        CurrentValue = Settings.FOVRadius,
        Flag = "FOVRadius",
        Callback = function(Value)
            Settings.FOVRadius = Value
        end,
    })

    MiscTab:CreateToggle({
        Name = "Enter French House (Barraux)",
        CurrentValue = Settings.EnterFrenchHouse or false,
        Flag = "EnterFrenchHouse",
        Callback = function()
            Settings.EnterFrenchHouse = not Settings.EnterFrenchHouse
            if game.workspace:FindFirstChild("ToggleAreas") then
                local warRoomBarriers = game.workspace.ToggleAreas:FindFirstChild("War Room Barriers")
                if warRoomBarriers then
                    for _, Part in pairs(warRoomBarriers:GetChildren()) do
                        if Part:IsA("BasePart") then
                            Part.CanCollide = not Settings.EnterFrenchHouse
                        end
                    end
                end
            end
        end,
    })
end

LoadUI()

local circle = Drawing.new("Circle")
circle.Radius = Settings.FOVRadius
circle.Color = Color3.fromRGB(255, 0, 255)
circle.Thickness = 1
circle.Filled = false
circle.Visible = false

local function isValidTarget(player)
    if not player then return false end
    if player == LP then return false end
    if not player.Character then return false end
    if not player.Character.HumanoidRootPart then return false end
    local humanoid = player.Character:FindFirstChild("Humanoid")
    if not humanoid then return false end
    if not player.Team then return false end
    if player.Team == LP.Team then return false end
    if humanoid.Health > 100 then return false end
    if humanoid.Health <= 0 then return false end

    return true
end

local function WorldToScreen(position)
    local screenPos, onScreen = Camera:WorldToScreenPoint(position)
    return screenPos, onScreen
end

local function GetClosestPlayerToCursor(players)
    local ClosestPlayer = nil
    local ClosestDistance = math.huge
    local MouseLocation = UserInputService:GetMouseLocation()

    for _, player in pairs(players) do
        if isValidTarget(player) then
            local humanoidRootPart = player.Character.HumanoidRootPart
            local screenPos2, onScreen2 = WorldToScreen(humanoidRootPart.Position)

            if onScreen2 then
                local screenPos2 = Vector2.new(screenPos2.X, screenPos2.Y)
                local distance = (screenPos2 - MouseLocation).Magnitude
                if ClosestDistance > distance then
                    ClosestPlayer = player
                    ClosestDistance = distance
                end
            end
        end
    end

    return ClosestPlayer
end

local function GetClosestPlayerToCFrame(TargetCFrame)
    local ClosestDistance = math.huge
    local ClosestPlayer = nil

    for _, player in pairs(Players:GetPlayers()) do
        if isValidTarget(player) then
            local playerCFrame = player.Character.HumanoidRootPart.CFrame
            local distance = (playerCFrame.Position - TargetCFrame.Position).Magnitude
            if distance < ClosestDistance then
                ClosestDistance = distance
                ClosestPlayer = player
            end
        end
    end

    return ClosestPlayer
end

local function AimAtTarget(target)
    if not target then return end
    
    local character = target.Character
    if not character then return end
    
    local targetPart = character:FindFirstChild("HumanoidRootPart")
    if not targetPart then return end
    
    local screenPoint3, onScreen3 = Camera:WorldToViewportPoint(targetPart.Position)
    if not onScreen3 then return end

    local MouseLocation = UserInputService:GetMouseLocation()
    local deltaX = screenPoint.X - MouseLocation.X
    local deltaY = screenPoint.Y - MouseLocation.Y
    
    local distance = math.sqrt(deltaX * deltaX + deltaY * deltaY)
    if distance < 1 then return end
    
    local scaleFactor = distance > 100 and 100 / distance or 1
    local smoothing = 1 / Settings.CursorAimSensitivity
    
    deltaX = deltaX * smoothing * scaleFactor
    deltaY = deltaY * smoothing * scaleFactor
    
    deltaX = math.clamp(deltaX, -10, 10)
    deltaY = math.clamp(deltaY, -10, 10)
    
    mousemoverel(deltaX, deltaY)
end

local function IsPlayerInCircle(player)
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local humanoidRootPart = player.Character.HumanoidRootPart
        local screenPos4, onScreen4 = WorldToScreen(humanoidRootPart.Position)

        if onScreen4 then
            local screenPos4 = Vector2.new(screenPos4.X, screenPos4.Y)
            local distance = (screenPos4 - circle.Position).Magnitude
            if distance <= circle.Radius then
                return true
            end
        end
    end
    return false
end

local function createEspBox()
    local Box = Drawing.new("Square")
    Box.Visible = false
    Box.Color = Color3.fromRGB(255, 255, 255)
    Box.Thickness = 2
    Box.Transparency = 0.8
    Box.Filled = false

    return {
        Box = Box,
        remove = function()
            Box:Remove()
        end
    }
end

local function updateEsp(player, espObject)
    if not Settings.ESP then 
        espObject.Box.Visible = false
        return
    end

    if Settings.TeamCheck and LP.Team == player.Team then
        espObject.Box.Visible = false
        return
    end
    
    if not player.Character then
        espObject.Box.Visible = false
        return
    end
    local Character = player.Character

    if not Character.HumanoidRootPart then
        espObject.Box.Visible = false
        return
    end
    local HumanoidRootPart = Character.HumanoidRootPart

    if not Character.Head then
        espObject.Box.Visible = false
        return
    end
    local Head = Character.Head

    if not Character.Humanoid then
        espObject.Box.Visible = false
        return
    end
    local Humanoid = Character.Humanoid
    
    if not Character or not HumanoidRootPart or not Head or not Humanoid then
        espObject.Box.Visible = false
        return
    end

    local distance = (LP.Character.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
    if distance > Settings.ESPRadius then
        espObject.Box.Visible = false
        return
    end

    local topPosition = Head.Position + Vector3.new(0, 1, 0)
    local bottomPosition = HumanoidRootPart.Position - Vector3.new(0, 3, 0)
    
    local screenTop, onScreenTop = workspace.CurrentCamera:WorldToViewportPoint(topPosition)
    local screenBottom, onScreenBottom = workspace.CurrentCamera:WorldToViewportPoint(bottomPosition)
    
    if not onScreenTop or not onScreenBottom then
        espObject.Box.Visible = false
        return
    end

    local boxHeight = math.abs(screenTop.Y - screenBottom.Y)
    local boxWidth = boxHeight * 0.6
    
    espObject.Box.Size = Vector2.new(boxWidth, boxHeight)
    espObject.Box.Position = Vector2.new(
        screenTop.X - boxWidth / 2,
        screenTop.Y
    )

    espObject.Box.Visible = true
end


for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        espObjects[player] = createEspBox()
    end
end

Players.PlayerAdded:Connect(function(player)
    espObjects[player] = createEspBox()
end)

local connection
connection = RunService.RenderStepped:Connect(function()
    -- aim if pressing keybind
    if Settings.CursorAim and Settings.CursorAimBindHeld and Settings.CursorAimTargetType ~= 0 and Settings.CursorAimType ~= 0 then
        if Settings.CursorAimTargetType == 1 then
            local playersInCircle = {}
            for _, player in pairs(Players:GetPlayers()) do
                if IsPlayerInCircle(player) then
                    table.insert(playersInCircle, player)
                end
            end
        
            if #playersInCircle > 0 then
                AimAtTarget(GetClosestPlayerToCursor(playersInCircle), Settings.CursorAimType)
            end
        end

        if Settings.CursorAimTargetType == 2 then
            AimAtTarget(GetClosestPlayerToCursor(Players:GetPlayers()), Settings.CursorAimType)
        end
    end

    -- update circle
    if Settings.CursorAim or Settings.SilentAim then
        circle.Radius = Settings.FOVRadius
        circle.Position = UserInputService:GetMouseLocation()
        circle.Visible = true
    else
        circle.Visible = false
    end

    -- update TargetPlayer if silent aim is enabled
    if Settings.SilentAim and Settings.SilentAimType ~= 0 then
        if Settings.SilentAimType == 1 then
            local Target = LP:GetMouse().Target
            if Target and Target.Parent then
                TargetPlayer = Players:GetPlayerFromCharacter(Target.Parent)
            end
        end

        if Settings.SilentAimType == 2 then
            local playersInCircle = {}
            for _, player in pairs(Players:GetPlayers()) do
                if isValidTarget(player) and IsPlayerInCircle(player) then
                    table.insert(playersInCircle, player)
                end
            end
        
            if #playersInCircle > 0 then
                TargetPlayer = GetClosestPlayerToCursor(playersInCircle) or nil
            end
        end

        if Settings.SilentAimType == 3 then
            local MouseCFrame = LP:GetMouse().Hit
            TargetPlayer = GetClosestPlayerToCFrame(MouseCFrame) or nil
        end
    end

    for player, espObject in pairs(espObjects) do
        if player ~= LP then
            updateEsp(player, espObject)
        end
    end
end)
