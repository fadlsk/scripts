local Settings = {
    -- aimbot
    CursorAim = false,
    CursorAimTargetType = 0,
    CursorAimType = 0,
    CursorAimBindHeld = false,
    CursorAimSensitivity = 1,

    -- esp
    SilentAim = false,
    SilentAimType = 0,

    -- misc
    FOVRadius = 150,
    EnterFrenchHouse = false,
}

local TargetPlayer = nil
local NetworkClient = nil

local function GetIdentifier(EventName)
    local success, result = pcall(function()
        if not NetworkClient then
            for _, script in pairs(getscripts()) do
                if script.Name == "NetworkClient" then
                    NetworkClient = script
                    break
                end
            end
        end

        if not NetworkClient then
            return nil, "NetworkClient script not found."
        end

        local req = require(NetworkClient)
        local event = req.getEvent(EventName)
        
        if event then
            return event.identifier
        else
            return nil, "Event not found."
        end
    end)

    if not success then
        print("Unexpected error:", result)
        return nil
    end

    return result
end

local Identifiers = {
    SelfReport = GetIdentifier("SelfReport"),
    FireProjectile = GetIdentifier("FireProjectile"),
    DealShot = GetIdentifier("DealShot"),
}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local LP = game.Players.LocalPlayer
local Network = ReplicatedStorage:WaitForChild("Network")
local RemoteEvent = Network:WaitForChild("RemoteEvent")

local function DealShot(TargetPlayer)
    local args = {
        {
            [Identifiers.DealShot] = {
                {
                    TargetPlayer,
                    false
                }
            }
        }
    }

    RemoteEvent:FireServer(unpack(args))
end

local mt = getrawmetatable(game)
if setreadonly then
    setreadonly(mt, false)
else
    make_writeable(mt)
end

local old = mt.__namecall
mt.__namecall = newcclosure(function(self, ...)
    local args = {...}
    local method = getnamecallmethod()

    if method == "FireServer" then
        local Break = false

        local success, err = pcall(function()
            if typeof(args) ~= "table" then
                return old(self, unpack(args))
            end

            for _, v in pairs(args) do
                if typeof(v) == "table" then
                    for Key, data in pairs(v) do
                        if Key == Identifiers.SelfReport then
                            for _, reasonTable in pairs(data) do
                                for i, reason in pairs(reasonTable) do
                                    if i == 2 then
                                        print("gory tried selfreporting :moyai:", reason)
                                    end
                                end
                            end
                            Break = true
                        end

                        if Settings.SilentAim and Key == Identifiers.FireProjectile then
                            DealShot(TargetPlayer)
                        end
                    end
                end
            end
        end)

        if not success then
            warn("Unexpected Error:", err)
        end
        if Break == true then
            return
        end
    end

    return old(self, unpack(args))
end)

if setreadonly then
    setreadonly(mt, true)
else
    make_readonly(mt)
end

local function ReturnKeys()
    local response = game:HttpGet("https://script.google.com/macros/s/AKfycbwpiBSmSyX8S0ojYgu0sNNhs6IfkFdjJ0H4p4eC4nurq4hXM_aGelK0pbJAXkBQd17UVQ/exec")
    local keys = HttpService:JSONDecode(response)

    local Tokens = {}
    for _, keyData in ipairs(keys) do
        if keyData[2] == LP.UserId and keyData[4] == false then
            return {keyData[1]}
        end
        table.insert(Tokens, keyData[1])

        if keyData[4] == true then
            continue
        end
    end

    return Tokens
end

local function LoadUI()
    local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/bruhmoments1234/rblx/refs/heads/main/RayfieldLib'))()
    local Window = Rayfield:CreateWindow({
        Name = "Spain Client for Napoleonic Wars",
        Icon = 10183122096,
        LoadingTitle = "Spain Client",
        LoadingSubtitle = "by Orpios",
        Theme = "Bloom",
    
        DisableRayfieldPrompts = false,
        DisableBuildWarnings = false,
    
        ConfigurationSaving = {
            Enabled = false,
            FolderName = "SpainClient",
            FileName = "Config"
        },
    
        Discord = {
            Enabled = false,
            Invite = "noinvitelink",
            RememberJoins = true
        },
    
        KeySystem = true,
        KeySettings = {
            Title = "Spain Client",
            Subtitle = "Key System",
            Note = "Ask the script owner.",
            FileName = "Key",
            SaveKey = true,
            GrabKeyFromSite = false,
            Key = ReturnKeys()
        }
    })
    
    local HomeTab = Window:CreateTab("Home", "home")
    HomeTab:CreateParagraph({Title = "Disclaimer!", Content = "The Spain Client is not responsible for any actions taken by the user. The script may experience errors or malfunctions, and its use may result in account blacklisting or other penalties. By using this script, you acknowledge and accept the potential risks. We do not assume any liability for bans, blacklisting, or any other consequences that may arise."})
    
    local AimbotTab = Window:CreateTab("Aimbot", "crosshair")
    local Section = AimbotTab:CreateSection("Cursor Aim")
    AimbotTab:CreateToggle({
        Name = "Cursor Aim",
        CurrentValue = Settings.CursorAim,
        Flag = "CursorAim",
        Callback = function()
            Settings.CursorAim = not Settings.CursorAim
        end,
    })

    AimbotTab:CreateDropdown({
        Name = "Target Type",
        Options = {"Closest to cursor", "Closest to cursor within FOV circle"},
        CurrentOption = {"Not Selected"},
        MultipleOptions = false,
        Flag = "CursorAimTargetType",
        Callback = function(Options)
            if Options[1] == "Closest to cursor within FOV circle" then
                Settings.CursorAimTargetType = 1
            elseif Options[1] == "Closest to cursor" then
                Settings.CursorAimTargetType = 2
            end
        end,
     })

    AimbotTab:CreateDropdown({
        Name = "Cursor Aim Type",
        Options = {"Slowly aim at target, smoothing applied", "Snap on the player, no smoothing applied (BROKEN)"},
        CurrentOption = {"Not Selected"},
        MultipleOptions = false,
        Flag = "CursorAimType",
        Callback = function(Options)
            if Options[1] == "Slowly aim at target, smoothing applied" then
                Settings.CursorAimType = 1
            elseif Options[1] == "Snap on the player, no smoothing applied (BROKEN)" then
                Settings.CursorAimType = 2
            end
        end,
     })

    AimbotTab:CreateKeybind({
        Name = "Cursor Aim Keybind",
        CurrentKeybind = "E",
        HoldToInteract = true,
        Flag = "CursorAimKeybind",
        Callback = function(Keybind)
            Settings.CursorAimBindHeld = Keybind
        end,
    })

    local Section = AimbotTab:CreateSection("Silent Aim")
    AimbotTab:CreateToggle({
        Name = "Silent Aim",
        CurrentValue = Settings.SilentAim,
        Flag = "SilentAim",
        Callback = function()
            Settings.SilentAim = not Settings.SilentAim
        end,
    })

    AimbotTab:CreateDropdown({
        Name = "Silent Aim Type",
        Options = {"Kill when mouse over player when firing", "Kill closest player in FOV circle when firing", "Rage Aim (Old Method, accidentally get extreme distances, closest to mouse)"},
        CurrentOption = {"Not Selected"},
        MultipleOptions = false,
        Flag = "SilentAimType",
        Callback = function(Options)
            if Options[1] == "Kill when mouse over player when firing" then
                Settings.SilentAimType = 1
            elseif Options[1] == "Kill closest player in FOV circle when firing" then
                Settings.SilentAimType = 2
            elseif Options[1] == "Rage Aim (Old Method, accidentally get extreme distances, closest to mouse)" then
                Settings.SilentAimType = 3
            end
        end,
    })

    local ESPTab = Window:CreateTab("ESP", "square")

    local MiscTab = Window:CreateTab("Misc", "pipette")
    MiscTab:CreateSlider({
        Name = "FOV Radius",
        Range = {0, 1500},
        Increment = 5,
        Suffix = "Radius",
        CurrentValue = Settings.FOVRadius,
        Flag = "FOVRadius",
        Callback = function(Value)
            Settings.FOVRadius = Value
        end,
    })

    MiscTab:CreateToggle({
        Name = "Enter French House (Barraux)",
        CurrentValue = Settings.EnterFrenchHouse or false,
        Flag = "EnterFrenchHouse",
        Callback = function()
            Settings.EnterFrenchHouse = not Settings.EnterFrenchHouse
            if game.workspace:FindFirstChild("ToggleAreas") then
                local warRoomBarriers = game.workspace.ToggleAreas:FindFirstChild("War Room Barriers")
                if warRoomBarriers then
                    for _, Part in pairs(warRoomBarriers:GetChildren()) do
                        if Part:IsA("BasePart") then
                            Part.CanCollide = not Settings.EnterFrenchHouse
                        end
                    end
                end
            end
        end,
    })
end

LoadUI()

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = game.Workspace.CurrentCamera
local Players = game:GetService("Players")
local LP = Players.LocalPlayer

local function isValidTarget(player)
    if not player then return false end
    if player == LP then return false end
    if not player.Character then return false end
    if not player.Character.HumanoidRootPart then return false end
    local humanoid = player.Character:FindFirstChild("Humanoid")
    if not humanoid then return false end
    if not player.Team then return false end
    if player.Team == LP.Team then return false end
    if humanoid.Health > 100 then return false end
    if humanoid.Health <= 0 then return false end

    return true
end

local function WorldToScreen(position)
    local screenPos, onScreen = Camera:WorldToScreenPoint(position)
    return screenPos, onScreen
end

local function GetClosestPlayerToCursor(players)
    local ClosestPlayer = nil
    local ClosestDistance = math.huge
    local MouseLocation = UserInputService:GetMouseLocation()

    for _, player in pairs(players) do
        if isValidTarget(player) then
            local humanoidRootPart = player.Character.HumanoidRootPart
            local screenPos, onScreen = WorldToScreen(humanoidRootPart.Position)

            if onScreen then
                local screenPos = Vector2.new(screenPos.X, screenPos.Y)
                local distance = (screenPos - MouseLocation).Magnitude
                if ClosestDistance > distance then
                    ClosestPlayer = player
                    ClosestDistance = distance
                end
            end
        end
    end

    return ClosestPlayer
end

local function GetClosestPlayerToCFrame(TargetCFrame)
    local ClosestDistance = math.huge
    local ClosestPlayer = nil

    for _, player in pairs(Players:GetPlayers()) do
        if isValidTarget(player) then
            local playerCFrame = player.Character.HumanoidRootPart.CFrame
            local distance = (playerCFrame.Position - TargetCFrame.Position).Magnitude
            if distance < ClosestDistance then
                ClosestDistance = distance
                ClosestPlayer = player
            end
        end
    end

    return ClosestPlayer
end

local function AimAtTarget(target)
    if not target then return end
    
    local character = target.Character
    if not character then return end
    
    local targetPart = character:FindFirstChild("HumanoidRootPart")
    if not targetPart then return end
    
    local screenPoint, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
    if not onScreen then return end

    local MouseLocation = UserInputService:GetMouseLocation()
    local deltaX = screenPoint.X - MouseLocation.X
    local deltaY = screenPoint.Y - MouseLocation.Y
    
    local distance = math.sqrt(deltaX * deltaX + deltaY * deltaY)
    if distance < 1 then return end
    
    local scaleFactor = distance > 100 and 100 / distance or 1
    local smoothing = 1 / Settings.CursorAimSensitivity
    
    deltaX = deltaX * smoothing * scaleFactor
    deltaY = deltaY * smoothing * scaleFactor
    
    deltaX = math.clamp(deltaX, -10, 10)
    deltaY = math.clamp(deltaY, -10, 10)
    
    mousemoverel(deltaX, deltaY)
end

local circle = Drawing.new("Circle")
circle.Radius = Settings.FOVRadius
circle.Color = Color3.fromRGB(255, 0, 255)
circle.Thickness = 1
circle.Filled = false
circle.Visible = false

local function IsPlayerInCircle(player)
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local humanoidRootPart = player.Character.HumanoidRootPart
        local screenPos, onScreen = WorldToScreen(humanoidRootPart.Position)

        if onScreen then
            local screenPos = Vector2.new(screenPos.X, screenPos.Y)
            local distance = (screenPos - circle.Position).Magnitude
            if distance <= circle.Radius then
                return true
            end
        end
    end
    return false
end


local connection
local i = 0
connection = RunService.RenderStepped:Connect(function()
    -- aim if pressing keybind
    if Settings.CursorAim and Settings.CursorAimBindHeld and Settings.CursorAimTargetType ~= 0 and Settings.CursorAimType ~= 0 then
        if Settings.CursorAimTargetType == 1 then
            local playersInCircle = {}
            for _, player in pairs(Players:GetPlayers()) do
                if IsPlayerInCircle(player) then
                    table.insert(playersInCircle, player)
                end
            end
        
            if #playersInCircle > 0 then
                AimAtTarget(GetClosestPlayerToCursor(playersInCircle), Settings.CursorAimType)
            end
        end

        if Settings.CursorAimTargetType == 2 then
            AimAtTarget(GetClosestPlayerToCursor(Players:GetPlayers()), Settings.CursorAimType)
        end
    end

    -- update circle
    if Settings.CursorAim or Settings.SilentAim then
        circle.Radius = Settings.FOVRadius
        circle.Position = UserInputService:GetMouseLocation()
        circle.Visible = true
    else
        circle.Visible = false
    end

    -- update TargetPlayer if silent aim is enabled
    if Settings.SilentAim and Settings.SilentAimType ~= 0 then
        if Settings.SilentAimType == 1 then
            local Target = LP:GetMouse().Target
            if Target and Target.Parent then
                TargetPlayer = Players:GetPlayerFromCharacter(Target.Parent)
            end
        end

        if Settings.SilentAimType == 2 then
            local playersInCircle = {}
            for _, player in pairs(Players:GetPlayers()) do
                if isValidTarget(player) and IsPlayerInCircle(player) then
                    table.insert(playersInCircle, player)
                end
            end
        
            if #playersInCircle > 0 then
                TargetPlayer = GetClosestPlayerToCursor(playersInCircle) or nil
            end
        end

        if Settings.SilentAimType == 3 then
            local MouseCFrame = LP:GetMouse().Hit
            TargetPlayer = GetClosestPlayerToCFrame(MouseCFrame) or nil
        end
    end
end)
